{"version":3,"sources":["webpack://PathToRegexp/webpack/universalModuleDefinition","webpack://PathToRegexp/webpack/bootstrap","webpack://PathToRegexp/./talend-umds/path-to-regexp/6.0.0/node_modules/path-to-regexp/dist/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","parse","str","options","tokens","length","char","push","type","index","count","pattern","j","TypeError","code","charCodeAt","lexer","_a","prefixes","defaultPattern","escapeString","delimiter","result","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","name_1","pattern_1","tokensToFunction","reFlags","flags","encode","x","_b","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","test","typeOfMessage","String","regexpToFunction","re","keys","decode","pathname","exec","params","_loop_1","split","replace","sensitive","tokensToRegexp","strict","start","_c","end","_d","endsWith","route","_i","tokens_1","mod","endToken","isEndDelimited","pathToRegexp","groups","source","match","regexpToRegexp","paths","parts","join","arrayToRegexp","stringToRegexp","compile"],"mappings":"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","file":"PathToRegexp.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PathToRegexp\"] = factory();\n\telse\n\t\troot[\"PathToRegexp\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += endsWith === \"$\" ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}